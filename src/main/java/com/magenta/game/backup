package com.magenta.game;

import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Random;

import org.joml.Math;
import org.joml.Vector3f;

import com.magenta.engine.Timer;
import com.magenta.render.TextureManager;

public class World {
	private TextureManager texManager;
	private LinkedList<BlockType> blockTypes = new LinkedList<>();
	private Map<Vector3f, Chunk> chunks = new LinkedHashMap<>();

	private final int WORLD_SIZE = 2; // this * this = WORLD_SIZE

	private enum BlocksEnum {
		AIR(0, null, null),
		COBBLESTONE(1, "cobblestone", new String[]{"cobblestone"}),
		GRASS(2, "grass", new String[]{"grass", "dirt", "grass_side"}),
		FULLGRASS(3, "fullgrass", new String[]{"grass"}),
		DIRT(4, "dirt", new String[]{"dirt"}),
		STONE(5, "stone", new String[]{"stone"}),
		SAND(6, "sand", new String[]{"sand"}),
		PLANKS(7, "planks", new String[]{"planks"}),
		LOG(8, "log", new String[]{"log_top", "log_side"});
		
		// DAISY(9),
		// ROSE(10),
		// CACTUS(11),
		// DEAD_BUSH(12);

		private final int id;
		private String name;
		private String[] textures;


		BlocksEnum(int id, String name, String[] textures) {
			this.id = id;
			this.name = name;
			this.textures = textures;
		}

		public int getId() {
			return id;
		}
		
		public String getName() {
			return name;
		}

		public String[] getTextures() {
			return textures;
		}
	}

	public World() {
		texManager = new TextureManager(16, 16, 256);


		// Add blocks dynamically
		blockTypes.add(BlocksEnum.AIR.getId(), null); // Id - 0	
		for(int i = 1; i < BlocksEnum.values().length; i++) {
			BlocksEnum blockEnum = BlocksEnum.values()[i];
			blockTypes.add(blockEnum.getId(), new BlockType(blockEnum.getName(), blockEnum.getTextures(), texManager) );
		}
		
		// blockTypes.add(0, null); // Id - 0	
		// blockTypes.add(new BlockType("cobblestone", new String[] { "cobblestone" }, texManager) ); // Id - 1
		// blockTypes.add(new BlockType("grass",       new String[] { "grass", "dirt", "grass_side" }, texManager) );
		// blockTypes.add(new BlockType("fullgrass",       new String[] { "grass" }, texManager) );
		
		// blockTypes.add(new BlockType("dirt",        new String[] { "dirt" }, texManager) );
		// blockTypes.add(new BlockType("stone",       new String[] { "stone" }, texManager) );
		// blockTypes.add(new BlockType("sand",        new String[] { "sand" }, texManager) );
		// blockTypes.add(new BlockType("planks",      new String[] { "planks" }, texManager) );
		// blockTypes.add(new BlockType("log",         new String[] { "log_top", "log_side" }, texManager) );

		// blockTypes.add(new BlockType("daisy",       new String[] { "daisy" }, plant_model, texManager));
		// blockTypes.add(new BlockType("rose",        new String[] { "rose" }, plat_model, texManager));
		// blockTypes.add(new BlockType("cactus",      new String[] { "cactus_top", "cactups_bottom", "cactus_side" }, cactus_model, texManager));
		// blockTypes.add(new BlockType("dead_bush",      new String[] { "dead_bush" }, plant_model, texManager));
		// blockTypes.add(new BlockType("devblock",    new String[] { "dev/r", "dev/l", "dev/t", "dev/bb", "dev/f", "dev/b" }, texManager) );
		// blockTypes.add( new BlockType("notfound",    new String[] { "notfound" }, texManager) ); // Default texture

		texManager.generateMipmap();

		// int[] firstRnd = {0, 9, 10};
		int[] firstRnd = {0, 7, 8};
		Random random = new Random();

		// Generate chunk randomly
		for(int xw = 0; xw < WORLD_SIZE; xw++) { // xw -> X World
			for(int zw = 0; zw < WORLD_SIZE; zw++) {
				Chunk currentChunk = new Chunk(this, new Vector3f(xw - 4, -1, zw - 4));
				int[][][] blocks = currentChunk.getBlocks();

				for(int x = 0; x < Chunk.CHUNK_WIDTH; x++) {
					for(int y = 0; y < Chunk.CHUNK_HEIGHT; y++) {
						for(int z = 0; z < Chunk.CHUNK_LENGTH; z++) {
							// if (y > 13) // Above Y=13 choose random in list of [ air, grass ] aka [0, 3] (block index 3)
							// 	blocks[x][y][z] = (random.nextInt(2) == 0) ? 0 : 3;
							// else // Bellow Y=13 choose random in list of [air, air, cooblestone]
							// 	blocks[x][y][z] = (random.nextInt(3) == 2) ? 1 : 0;

							// Flowers //
							// if(y == 15)
							// 	blocks[x][y][z] = firstRnd[random.nextInt(firstRnd.length)];
							// else if(y == 14)
							// 	blocks[x][y][z] = 2;
							// else if(y > 10)
							// 	blocks[x][y][z] = 4;
							// else
							// 	blocks[x][y][z] = 5;

							// Big block chunk //
							blocks[x][y][z] = 1;
						}
					}
				}

				chunks.put(currentChunk.getChunkPosition(), currentChunk); // Add to chunks list
			}
		}


		// Update each chunk's mesh
		Timer timer = new Timer();

		System.out.println("\n=> Loading world...");
		for(Chunk chunk : chunks.values()) {
			// System.out.println("Chunks size: " + chunks.values().size());
			chunk.updateMesh();
		}

		float elapsed = (float) timer.getElapsedTime();
		System.out.println("=> Loaded world in: " + elapsed + " seconds");
		System.out.println("Average: " + elapsed / chunks.size() + " per chunk\n");
	}


	public Vector3f getChunkPosition(Vector3f position) {
		return new Vector3f(
			(float) Math.floor(position.x / Chunk.CHUNK_WIDTH),
			(float) Math.floor(position.y / Chunk.CHUNK_HEIGHT),
			(float) Math.floor(position.z / Chunk.CHUNK_LENGTH)
		);
	}

	public Vector3f getLocalPosition(Vector3f position) {
		Vector3f chunk = getChunkPosition(position);
		return new Vector3f(
			position.x - (chunk.x * Chunk.CHUNK_WIDTH),
			position.y - (chunk.y * Chunk.CHUNK_HEIGHT),
			position.z - (chunk.z * Chunk.CHUNK_LENGTH)
		);
	}

	// Get the index in the BlockManager array of the block at a certain position
	public int getBlockNumber(float x, float y, float z) {
		// Get the chunk in wich the block it's position
		// Vector3f chunkPosition = new Vector3f((float) Math.floor(x / Chunk.CHUNK_WIDTH), (float) Math.floor(y / Chunk.CHUNK_HEIGHT), (float) Math.floor(z / Chunk.CHUNK_LENGTH));
		Vector3f chunkPosition = getChunkPosition(new Vector3f(x, y, z));

		// Return "air" if the chunk doens't exist
		if(chunks.get(chunkPosition) == null)
			return 0;

		// Get the relative position of the block in the chunk
		Vector3f temp = getLocalPosition(new Vector3f(x, y, z));
		return chunks.get(chunkPosition).getBlock((int) temp.x, (int) temp.y, (int) temp.z);
		// return the block number at the local position in the correct chunk
	}

	public int getBlockNumber(Vector3f position) {
		return getBlockNumber(position.x, position.y, position.z);
	}


	// Get block type and check if it's opaque or not
	public boolean isOpaqueBlock(Vector3f position) {
		// Air counts as a transparent block, so test for that or not
		int blockNumber = getBlockNumber(position.x, position.y, position.z);
		if(blockTypes.get(blockNumber) != null)
			return !blockTypes.get(blockNumber).isTransparent(); // Not transparent = Opaque
		return false; // Air
	}

	public boolean isOpaqueBlock(float x, float y, float z) {
		return isOpaqueBlock(new Vector3f(x, y, z));
	}


	// public int getBlock(Vector3f position) {
	// 	Vector3f chunkPosition = getChunkPosition(position);
		
	// 	// If no chunks exist at this position, create a new one
	// 	Chunk currentChunk;
	// 	if(!chunks.containsKey(chunkPosition)) {
	// 		currentChunk = new Chunk(this, chunkPosition);
	// 		chunks.put(chunkPosition, currentChunk);
	// 	} else {
	// 		currentChunk = chunks.get(chunkPosition);
	// 	}	

	// 	// No point updating mesh if the block is the same
	// 	Vector3f localPosition = getLocalPosition(position);
	// 	int lx = (int) localPosition.x;
	// 	int ly = (int) localPosition.y;
	// 	int lz = (int) localPosition.z;

	// 	return currentChunk.getBlocks()[lx][ly][lz];
	// }

	// Set number to 0 (air) to remove block
	public void setBlock(Vector3f position, int number) {
		Vector3f chunkPosition = getChunkPosition(position);
		
		// If no chunks exist at this position, create a new one
		Chunk currentChunk;
		if(!chunks.containsKey(chunkPosition)) {
			// No point in creating a whole new chunk if we're not gonna be adding anything
			if(number == 0) return;

			currentChunk = new Chunk(this, chunkPosition);
			chunks.put(chunkPosition, currentChunk);
		} else {
			currentChunk = chunks.get(chunkPosition);
		}

		

		// No point updating mesh if the block is the same
		int lastBlockNumber = getBlockNumber(position.x, position.y, position.z);
		if(lastBlockNumber == number) return;

		Vector3f localPosition = getLocalPosition(position);
		int lx = (int) localPosition.x;
		int ly = (int) localPosition.y;
		int lz = (int) localPosition.z;

		currentChunk.getBlocks()[lx][ly][lz] = number;

		int cx = (int) chunkPosition.x;
		int cy = (int) chunkPosition.y;
		int cz = (int) chunkPosition.z;

		// Check if position is located at chunk border
		if(lx == (Chunk.CHUNK_WIDTH - 1))
			tryUpdateChunkMesh(cx + 1, cy, cz);
		if(lx == 0)
			tryUpdateChunkMesh(cx - 1, cy, cz);

		if(ly == (Chunk.CHUNK_HEIGHT - 1))
			tryUpdateChunkMesh(cx, cy + 1, cz);
		if(ly == 0)
			tryUpdateChunkMesh(cx, cy - 1, cz);

		if(lz == (Chunk.CHUNK_LENGTH - 1))
			tryUpdateChunkMesh(cx, cy, cz + 1);
		if(lz == 0)
			tryUpdateChunkMesh(cx, cy, cz - 1);	

		currentChunk.updateMesh();
	}

	public void tryUpdateChunkMesh(float x, float y, float z) {
		Vector3f chunkPosition = new Vector3f(x, y, z);
		if(chunks.containsKey(chunkPosition))
			chunks.get(chunkPosition).updateMesh();
	}


	public LinkedList<BlockType> getBlockTypes() {
		return blockTypes;
	}

	public Map<Vector3f, Chunk> getChunks() {
		return chunks;
	}

	public TextureManager getTexManager() {
		return texManager;
	}



	// Render all chunks
	public void render() {
		for(Chunk chunk : chunks.values()) {
			chunk.draw();
		}
	}
}

































package com.magenta.game;

import java.util.Iterator;
import java.util.LinkedList;

import org.joml.Vector3f;
import org.lwjgl.opengl.GL11;
import org.lwjgl.opengl.GL30;

import com.magenta.render.mesh.Mesh;
import com.magenta.render.mesh.MeshLoader;

public class Chunk {
	public final static int CHUNK_WIDTH = 16;
	public final static int CHUNK_HEIGHT = 16;
	public final static int CHUNK_LENGTH = 16;

	private LinkedList<Float> vertexPositions = new LinkedList<>();
	private LinkedList<Float> texCoords = new LinkedList<>();
	private LinkedList<Integer> indices = new LinkedList<>();
	private LinkedList<Float> shadingValues = new LinkedList<>();
	private int meshIndexCounter = 0;

	private Vector3f chunkPosition;
	private final Vector3f realPosition;

	private World world;
	private int[][][] blocks;

	private Mesh mesh;

	public Chunk(World world, Vector3f chunkPosition) {
		this.world = world;
		this.chunkPosition = chunkPosition;
		this.realPosition = new Vector3f(chunkPosition).mul(CHUNK_WIDTH, CHUNK_HEIGHT, CHUNK_LENGTH); // World-space position for the chunk
		this.blocks = new int[CHUNK_WIDTH][CHUNK_HEIGHT][CHUNK_LENGTH]; // 0 -> air (default)
	}

	public void updateMesh() {
		// Reset values
		vertexPositions.clear();
		texCoords.clear();
		indices.clear();
		shadingValues.clear();

		meshIndexCounter = 0;


		// Iterate throught all local block positions in the chunk
		for(int localX = 0; localX < CHUNK_WIDTH; localX++) {	
			for(int localY = 0; localY < CHUNK_HEIGHT; localY++) {
				for(int localZ = 0; localZ < CHUNK_LENGTH; localZ++) {
					int blockNumber = this.blocks[localX][localY][localZ];

					// System.out.println("Block Number: " + blockNumber + "\nSize: " + this.world.getBlockTypes().size());
					// Vector3f localPos = new Vector3f(localX, localY, localZ);

					// Not air
					if(blockNumber > 0) {
						BlockType blockType = this.world.getBlockTypes().get(blockNumber);

						// Get the world-space position of the block
						float x = realPosition.x + localX;
						float y = realPosition.y + localY;
						float z = realPosition.z + localZ;

						/***
						 * If block is cube, we want it to check neighbouring blocks so that we don't uselessly render faces
						 * If block isn't a cube, we just want to render all faces, regardless of neighbouring blocks
						 * Since the vast majority of blocks are probably anyway going to be cubes, this won't impact performance all that much; the amount of useless faces drawn is going to be minimal
						 * */
						if(!world.isOpaqueBlock(x + 1, y, z)) // Block on side is transparent (or air) so draw this face, because it's visible
							addFace(0, blockType, x, y, z);
						if(!world.isOpaqueBlock(x - 1, y, z))
							addFace(1, blockType, x, y, z);

						if(!world.isOpaqueBlock(x, y + 1, z))
							addFace(2, blockType, x, y, z);
						if(!world.isOpaqueBlock(x, y - 1, z))
							addFace(3, blockType, x, y, z);

						if(!world.isOpaqueBlock(x, y, z + 1))
							addFace(4, blockType, x, y, z);
						if(!world.isOpaqueBlock(x, y, z - 1))
							addFace(5, blockType, x, y, z);
					}
				}
			}
		}

		// Pass mesh data to gpu
		if(meshIndexCounter == 0) // Mak sure there actually is data in the mesh
			return;

		this.mesh = MeshLoader.createMesh(convertFloats(vertexPositions), convertIntegers(indices), convertFloats(texCoords), convertFloats(shadingValues));
	}

	// Add a face to the chunk mesh
	public void addFace(int face, BlockType block, float x, float y, float z) {
		float[] vertexPositions = block.getVertexPositions()[face].clone(); // Get vertex positions of the face to be added

		// Add the world-space position of the face to it's vertex positions
		for(int i = 0; i < 4; i++) {
			vertexPositions[i * 3 + 0] += x;
			vertexPositions[i * 3 + 1] += y;
			vertexPositions[i * 3 + 2] += z;
		}

		// Add those vertex positions to the chunk mesh's vertex positions
		for(int i = 0; i < vertexPositions.length; i++) {
			this.vertexPositions.add(i, vertexPositions[i]);
		}
	
		// Shift each index by the chunk mesh's index counter so that no two faces share
		int[] indices = new int[] { 0, 1, 2, 0, 2, 3 }; // Indices for the face's vertices
		for(int i = 0; i < indices.length; i++) {
			this.indices.add(i, indices[i] + meshIndexCounter);
		}
		meshIndexCounter += 4; // Add "the amount of vertices" in a face to the chunk

		// Add the face's texture coordinates to the chunk mesh's texture coordinates
		float[] texCoords = block.getTexCoords()[face];
		for(int i = 0; i < texCoords.length; i++) {
			this.texCoords.add(i, texCoords[i]);
		}

		// Add the face's shading values to the chunk mesh's shading values
		float[] shadingValues = block.getShadingValues()[face];
		for(int i = 0; i < shadingValues.length; i++) {
			this.shadingValues.add(i, shadingValues[i]);
		}
	}




	public int getBlock(int x, int y, int z) {
		int blockTypeID = blocks[x][y][z];

		if(blockTypeID == 0)
			return 0; // Return air

		BlockType blockType = world.getBlockTypes().get(blockTypeID);
		if(blockType.isTransparent())
			return 0;
		else
			return blockTypeID;
	}



	public int[][][] getBlocks() {
		return blocks;
	}

	public Vector3f getChunkPosition() {
		return chunkPosition;
	}

	public Mesh getMesh() {
		return mesh;
	}

	public World getWorld() {
		return world;
	}



	private float[] convertFloats(LinkedList<Float> floats) {
		float[] ret = new float[floats.size()];
		Iterator<Float> iterator = floats.iterator();
		for (int i = 0; i < ret.length; i++) {
			ret[i] = iterator.next();
		}
		return ret;
	}

	private int[] convertIntegers(LinkedList<Integer> integers) {
		int[] ret = new int[integers.size()];
		Iterator<Integer> iterator = integers.iterator();
		for (int i = 0; i < ret.length; i++) {
			ret[i] = iterator.next();
		}
		return ret;
	}

	// Render chunk
	public void draw() {
		// Make sure there actually is data in mesh
		if(meshIndexCounter == 0)
			return;

		GL30.glBindVertexArray(mesh.getVaoID()); // Unloads VAO
		GL11.glDrawElements(GL11.GL_TRIANGLES, mesh.getVertexCount(), GL11.GL_UNSIGNED_INT, 0); // Draw triangle	
	}
}